<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<title>Three.js Grid + HTML Overlay</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<link rel="stylesheet" href="style/theme.css" />
	<link rel="stylesheet" href="style/gallery.css" />
	<link rel="stylesheet" href="style/hud.css" />
	<link rel="stylesheet" href="style/window.css" />
	<link rel="stylesheet" href="style/menu.css" />
	<link rel="stylesheet" href="style/metrics.css" />	

	<script type="text/javascript" src="./library/socket.io.min.js"></script>
	<script type="text/javascript" src="./library/moveable.min.js"></script>
</head>

<body>

	<div id="root">
		<div id="three-layer"></div>
		<div id="ui-layer">
			<div id="overlay">

				<div>
					<svg width="220" height="50" viewBox="0 0 350 70" xmlns="http://www.w3.org/2000/svg">
						<defs>
							<style type="text/css">
								@import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&amp;family=Inter:wght@400;900&amp;display=swap');
							</style>
							
							<filter id="softShadow" x="-20%" y="-20%" width="150%" height="150%">
								<feGaussianBlur in="SourceAlpha" stdDeviation="2" /> <feOffset dx="2" dy="2" result="offsetblur" /> <feComponentTransfer>
									<feFuncA type="linear" slope="0.3"/> </feComponentTransfer>
								<feMerge>
									<feMergeNode /> <feMergeNode in="SourceGraphic" /> </feMerge>
							</filter>
						</defs>
						<text x="30" y="50" 
							font-family="'Inter', -apple-system, sans-serif" 
							font-size="30" 
							fill="currentColor" 
							filter="url(#softShadow)"> <tspan font-weight="900" fill="#404040">FEM</tspan><tspan font-weight="400">ULATOR</tspan>
							<tspan dx="5" dy="3" font-family="'Dancing Script', cursive" font-size="42" fill="#FB2C36">Pro</tspan>
						</text>
					</svg>
				</div>

				<div id="application-menu-container"></div>

				<div class="hud gallery" id="hud-gallery" style="z-index: 15;">

					<h1>MESH GALLERY</h1>
					<div class="sep"></div>

					<div class="gallery-container" class="gallery-container">

						<div class="caroussel-wrapper">
							<div class="carousel-container">
								<div class="carousel-track" id="carouselTrack">
								</div>
							</div>
							<div class="nav-dots" id="navDots"></div>
							<div class="carousel-controls">
								<button class="btn" id="prevBtn">Previous</button>
								<div class="btn-group">
									<button class="btn btn-secondary" id="cancelBtn">Cancel</button>
									<button class="btn btn-primary" id="selectBtn">Select Model</button>
								</div>
								<button class="btn" id="nextBtn">Next</button>
							</div>
						</div>

					</div>

				</div>

				<div class="hud metrics visible" id="hud-metrics" style="z-index: 15;">

					<h1>PERFORMANCE METRICS</h1>
					<div class="sep"></div>

					<div class="metrics-container">
					</div>

				</div>

				<div class="hud benchmark" id="hud-benchmark" style="z-index: 15;">

					<h1>BENCHMARK ANALYSIS</h1>
					<div class="sep"></div>

					<div class="benchmark-container">
					</div>

				</div>

				<div class="hud report" id="hud-report" style="z-index: 15;">

					<h1>PROJECT REPORT</h1>
					<div class="sep"></div>

					<div class="report-container">
					</div>

				</div>

				<div class="hud settings" id="hud-settings" style="z-index: 15;">

					<h1>CONFIGURATION SETTINGS</h1>
					<div class="sep"></div>

					<div class="settings-container">
					</div>

				</div>

				<div class="hud about" id="hud-about" style="z-index: 15;">

					<h1>ABOUT FEMULATOR PRO</h1>
					<div class="sep"></div>

					<div class="about-container">
					</div>

				</div>


			</div>
		</div>
	</div>

	<script type="module">
		import { MillimetricScene } from './script/scene.js';
		import { FEMClient } from './script/fem-client.js';
		import { MetricsDisplay } from './script/metrics-display.js';
		import { FEMMeshRendererCPU } from './script/fem-mesh-renderer-cpu.js';
		import { FEMMeshRendererGPU } from './script/fem-mesh-renderer-gpu.js';
		import { MeshExtruderSDF } from './script/mesh-extruder-sdf.js';

		// ============================================================================
		// Configuration
		// ============================================================================
		const useGPU = false;              // Use GPU renderer (false = CPU)
		const use3DExtrusion = true;       // Enable 3D extrusion of mesh
		const useParticleAnimation = false; // Enable particle flow animation (TODO)

		// ============================================================================
		// Initialize Three.js scene
		// ============================================================================
		const container = document.getElementById('three-layer');
		const millimetricScene = new MillimetricScene(container);

		// ============================================================================
		// Initialize FEM client and metrics display
		// ============================================================================
		const femClient = new FEMClient('http://localhost:4567');
		const metricsDisplay = new MetricsDisplay(document.getElementById('hud-metrics'));
		
		// Initialize mesh renderer (for 2D visualization)
		const meshRenderer = useGPU 
			? new FEMMeshRendererGPU(millimetricScene.getScene()) 
			: new FEMMeshRendererCPU(millimetricScene.getScene());

		// 3D mesh extruder (initialized after solve completes)
		let meshExtruder = null;
		let animationFrameId = null;

		// ============================================================================
		// Socket.IO Event Handlers
		// ============================================================================
		
		femClient.on('connected', () => {
			metricsDisplay.updateStatus('Connected');
			console.log('‚úÖ Connected to FEM server');
		});

		femClient.on('stage_start', (data) => {
			metricsDisplay.updateStage(data.stage);
			metricsDisplay.updateStatus('Running');
		});

		femClient.on('mesh_loaded', (data) => {
			metricsDisplay.updateMesh(data.nodes, data.elements);
			
			// Store mesh data for later use
			window.currentMeshData = data;
			
			// Render mesh if coordinates are available
			if (data.coordinates && data.connectivity) {
				if (!use3DExtrusion) {
					// Standard 2D visualization
					meshRenderer.loadMesh(data);
					millimetricScene.render();
				}
				// If using 3D extrusion, we'll render after solve completes
			}
		});

		femClient.on('solve_progress', (data) => {
			metricsDisplay.updateProgress(
				data.iteration,
				data.max_iterations,
				data.residual,
				data.etr_seconds
			);
		});

		femClient.on('solve_complete', async (data) => {
			metricsDisplay.updateStatus('Complete');
			metricsDisplay.updateTotalTime(data.timing_metrics.total_program_time);
			console.log('üéâ Solve complete!', data);
			
			// Check if we have solution data
			if (!data.solution_field) {
				console.error('‚ùå No solution field in results');
				return;
			}
			
			const solutionData = {
				values: Array.from(data.solution_field),
				range: data.solution_stats.u_range
			};
			
			// ========================================================================
			// 3D Extrusion Mode
			// ========================================================================
			if (use3DExtrusion) {
				try {
					console.log('üåä Creating 3D extruded visualization...');
					
					// Fetch velocity data (optional for coloring)
					let velocityData = null;
					try {
						const velocityUrl = `/solve/${data.job_id}/velocity/binary`;
						const response = await fetch(`http://localhost:4567${velocityUrl}`);
						
						if (response.ok) {
							const buffer = await response.arrayBuffer();
							velocityData = parseVelocityBinary(buffer, data.mesh_info.elements);
							console.log('‚úÖ Velocity data loaded:', velocityData);
						} else {
							console.warn('‚ö†Ô∏è  Velocity data not available, using solution only');
						}
					} catch (velocityError) {
						console.warn('‚ö†Ô∏è  Could not fetch velocity:', velocityError);
					}
					
					// Create mesh extruder with both 2D and 3D views
					meshExtruder = new MeshExtruderSDF(
						millimetricScene.getScene(),
						window.currentMeshData,
						solutionData,
						{
							show2DMesh: true,           // Keep 2D mesh visible
							show3DExtrusion: true,      // Show 3D extrusion
							extrusionDepth: 2.0,        // Extrusion depth in Z
							extrusionOpacity: 0.6       // Transparency of 3D mesh
						}
					);

					meshExtruder.createAll();
					millimetricScene.render();

					window.meshExtruder = meshExtruder;					
					
					console.log('‚úÖ 3D extrusion created successfully');
					
					// TODO: Add particle animation if enabled
					if (useParticleAnimation && velocityData) {
						console.log('üé® Starting particle animation...');
						// Animation loop will go here
					}
					
				} catch (error) {
					console.error('‚ùå Failed to create 3D extrusion:', error);
					
					// Fallback to standard 2D visualization
					console.log('‚ö†Ô∏è  Falling back to 2D visualization');
					meshRenderer.loadMesh(window.currentMeshData);
					meshRenderer.updateSolution(solutionData);
					millimetricScene.render();
				}
			} 
			// ========================================================================
			// Standard 2D Mode
			// ========================================================================
			else {
				console.log('üìê Using standard 2D visualization');
				meshRenderer.updateSolution(solutionData);
				millimetricScene.render();
			}
		});

		femClient.on('solution_increment', (data) => {
			// Only update during solve if NOT using 3D extrusion
			if (!use3DExtrusion) {
				meshRenderer.updateSolutionIncremental(data);
				millimetricScene.render();
				
				console.log(`Solution update: iter ${data.iteration}, ` +
							`range [${data.chunk_info.min.toFixed(3)}, ${data.chunk_info.max.toFixed(3)}]`);
			}
		});
		
		// ============================================================================
		// Helper Functions
		// ============================================================================
		
		/**
		* Parse binary velocity data
		* Format: [count(4 bytes), vx0(4), vy0(4), vx1(4), vy1(4), ...]
		*/
		function parseVelocityBinary(buffer, expectedElements) {
			const view = new DataView(buffer);
			let offset = 0;
			
			// Read header (number of elements)
			const count = view.getUint32(offset, true);
			offset += 4;
			
			console.log(`Parsing velocity data: ${count} elements (expected: ${expectedElements})`);
			
			if (count !== expectedElements) {
				console.warn(`Element count mismatch: got ${count}, expected ${expectedElements}`);
			}
			
			// Read velocity vectors
			const vel = [];
			const abs_vel = [];
			
			// Calculate expected buffer size
			const expectedSize = 4 + (count * 2 * 4); // header + (count * 2 floats * 4 bytes)
			
			if (buffer.byteLength < expectedSize) {
				throw new Error(`Buffer too small: ${buffer.byteLength} < ${expectedSize}`);
			}
			
			for (let i = 0; i < count; i++) {
				// Check bounds before reading
				if (offset + 8 > buffer.byteLength) {
					console.error(`Buffer overflow at element ${i}, offset ${offset}`);
					break;
				}
				
				const vx = view.getFloat32(offset, true);
				offset += 4;
				const vy = view.getFloat32(offset, true);
				offset += 4;
				
				vel.push([vx, vy]);
				abs_vel.push(Math.sqrt(vx * vx + vy * vy));
			}
			
			console.log(`‚úÖ Parsed ${vel.length} velocity vectors`);
			console.log(`   Speed range: [${Math.min(...abs_vel).toFixed(3)}, ${Math.max(...abs_vel).toFixed(3)}]`);
			
			return { vel, abs_vel };
		}

		// ============================================================================
		// Expose to Window for Console Testing
		// ============================================================================
		
		window.femClient = femClient;
		window.metricsDisplay = metricsDisplay;
		window.meshRenderer = meshRenderer;
		window.millimetricScene = millimetricScene;
		window.meshExtruder = meshExtruder;
		
		// ============================================================================
		// Console Helper Functions
		// ============================================================================
		
		/**
		* Toggle 2D mesh visibility
		* Usage: toggle2DMesh(false)  // Hide 2D mesh
		*/
		window.toggle2DMesh = (visible) => {
			if (meshExtruder) {
				meshExtruder.set2DMeshVisible(visible);
				millimetricScene.render();
				console.log(`üìê 2D mesh: ${visible ? 'visible' : 'hidden'}`);
			} else {
				console.warn('‚ö†Ô∏è  Mesh extruder not initialized');
			}
		};
		
		/**
		* Toggle 3D extrusion visibility
		* Usage: toggle3DExtrusion(true)  // Show 3D extrusion
		*/
		window.toggle3DExtrusion = (visible) => {
			if (meshExtruder) {
				meshExtruder.set3DExtrusionVisible(visible);
				millimetricScene.render();
				console.log(`üåä 3D extrusion: ${visible ? 'visible' : 'hidden'}`);
			} else {
				console.warn('‚ö†Ô∏è  Mesh extruder not initialized');
			}
		};
		
		/**
		* Update extrusion configuration
		* Usage: updateExtrusionConfig({ extrusionDepth: 5.0, extrusionOpacity: 0.8 })
		*/
		window.updateExtrusionConfig = (newConfig) => {
			if (meshExtruder) {
				Object.assign(meshExtruder.config, newConfig);
				console.log('‚úÖ Extrusion config updated:', meshExtruder.config);
				
				// Recreate mesh with new config
				meshExtruder.create3DExtrusion();
				millimetricScene.render();
			} else {
				console.warn('‚ö†Ô∏è  Mesh extruder not initialized');
			}
		};
		
		/**
		* Quick test: Start a solve
		* Usage: quickSolve()
		*/
		window.quickSolve = () => {
			femClient.startSolve({
				mesh_file: '/home/logus/env/iscte/cgad_pro/data/input/converted_mesh_v5.h5',
				solver_type: 'cpu',
				max_iterations: 5000,
				progress_interval: 50
			});
		};
		
		// ============================================================================
		// Log Configuration on Startup
		// ============================================================================
		console.log('‚öôÔ∏è  FEMulator Pro Configuration:');
		console.log(`   GPU Rendering: ${useGPU ? 'Enabled' : 'Disabled'}`);
		console.log(`   3D Extrusion: ${use3DExtrusion ? 'Enabled' : 'Disabled'}`);
		console.log(`   Particle Animation: ${useParticleAnimation ? 'Enabled' : 'Disabled'}`);
		console.log('\nüí° Console helpers available:');
		console.log('   toggle2DMesh(true/false)');
		console.log('   toggle3DExtrusion(true/false)');
		console.log('   updateExtrusionConfig({...})');
		console.log('   quickSolve()');
	</script>

	<script type="module" src="./script/menu.init.js"></script>
	<script type="module" src="./script/moveable.init.js"></script>

</body>

</html>